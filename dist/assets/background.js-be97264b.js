import{S as M,D as T,s as D,a as b,t as f,b as E,l as F,c as S,z as A,T as $}from"./register_all_kernels-99d2b967.js";import"./_commonjsHelpers-de833af9.js";/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class h{constructor(o){this.modelArtifacts=o}load(){return this.modelArtifacts}}class I{constructor(o){this.saveHandler=o}save(o){return this.saveHandler(o)}}class P{constructor(o){o.load&&(this.load=()=>Promise.resolve(o.load())),o.save&&(this.save=r=>Promise.resolve(o.save(r)))}}function N(e,o,r,t){const a=arguments;return new P(L(...a))}function L(e,o,r,t){return arguments.length===1?e.modelTopology!=null||e.weightSpecs!=null?new h(e):(console.warn("Please call tf.io.fromMemory() with only one argument. The argument should be of type ModelArtifacts. The multi-argument signature of tf.io.fromMemory() has been deprecated and will be removed in a future release."),new h({modelTopology:e})):(console.warn("Please call tf.io.fromMemory() with only one argument. The argument should be of type ModelArtifacts. The multi-argument signature of tf.io.fromMemory() has been deprecated and will be removed in a future release."),new h({modelTopology:e,weightSpecs:o,weightData:r,trainingConfig:t}))}function _(e){return new I(e)}/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */function x(e){return new M(e)}/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */function w(e){return new T(e)}D("wasm").then(()=>console.log("ReelSense: TF.js backend set to WASM.")).catch(e=>console.error("ReelSense: Failed to set WASM backend:",e));const y={enabled:!0,mindlessThreshold:70,interventionType:"nudge",pauseDuration:60,genreFatigueLimit:15,scrollSpeedThreshold:5,minWatchTime:3,dailyLimit:120,showStats:!0};let l=null;const c=["scrollSpeed","avgWatchTime","skipRate","genreDiversity","sessionMinutes"];chrome.tabs.onRemoved.addListener(e=>{console.log(`Cleaned up session for closed tab: ${e}`)});chrome.runtime.onInstalled.addListener(async e=>{console.log("ReelSense installed/updated:",e.reason),e.reason==="install"&&(await chrome.storage.local.set({settings:y}),await chrome.storage.local.set({trainingData:[]})),await m(),await p(),chrome.alarms.create("dailyReset",{when:z(),periodInMinutes:1440})});p();chrome.alarms.onAlarm.addListener(async e=>{e.name==="dailyReset"&&await C()});async function m(){const e=new Date().toDateString(),o=await chrome.storage.local.get(["dailyStats","lastStatsDate"]);if(o.lastStatsDate!==e||!o.dailyStats){console.log("Initializing daily stats for",e);const r={date:e,instagram:{time:0,videos:0,interventions:0},youtube:{time:0,videos:0,interventions:0},totalMindlessScore:0,highestMindlessScore:0};await chrome.storage.local.set({dailyStats:r,lastStatsDate:e})}}async function C(){console.log("Resetting daily stats via alarm."),await m()}function z(){const e=new Date;return e.setDate(e.getDate()+1),e.setHours(0,0,0,0),e.getTime()}chrome.runtime.onMessage.addListener((e,o,r)=>{switch(e.action){case"TRAIN_MODEL":return console.log("ReelSense: Manual training trigger received."),v().then(()=>r({success:!0,message:"Model training complete!"})).catch(t=>{console.error("ReelSense: Training failed",t),r({success:!1,error:t.message})}),!0;case"logTrainingData":return R(e.features,e.label).then(t=>{r({success:!0}),t>30&&t%5===0&&(console.log(`ReelSense: Auto-training model at ${t} samples.`),v().catch(a=>console.error("Auto-train failed:",a)))}).catch(t=>{console.error("Error logging training data:",t),r({success:!1,error:"Failed to log data"})}),!0;case"PREDICT_BEHAVIOR":if(!l)return console.log("Prediction requested, but model not loaded."),r({success:!1,error:"Model not loaded"}),!1;try{const t=k(e.features);r({success:!0,prediction:t})}catch(t){console.error("Prediction error:",t),r({success:!1,error:t.message})}return!1;case"updateStats":return O(e.platform,e.data).then(()=>r({success:!0})).catch(t=>{console.error("Error updating stats:",t),r({success:!1,error:"Failed to update stats"})}),!0;case"getSettings":return chrome.storage.local.get("settings").then(t=>r(t.settings||y)).catch(t=>{console.error("Error getting settings:",t),r(y)}),!0;case"recordIntervention":return U(e.platform,e.type).then(()=>r({success:!0})).catch(t=>{console.error("Error recording intervention:",t),r({success:!1,error:"Failed to record intervention"})}),!0;default:return console.log("Unknown action received:",e.action),r({success:!1,error:"Unknown action"}),!1}});async function R(e,o){var r;try{const a=(await chrome.storage.local.get("trainingData")).trainingData||[];if(typeof e!="object"||typeof o!="number"||o<0||o>1)return console.warn("Invalid training data received:",{features:e,label:o}),a.length;if(!c.every(u=>typeof e[u]=="number"&&Number.isFinite(e[u])))return console.warn("Invalid features received:",e),a.length;const g={features:e,label:o};a.push(g);const s=500;return a.length>s&&a.splice(0,a.length-s),await chrome.storage.local.set({trainingData:a}),console.log(`Logged sample ${a.length}: L=${o} F=${JSON.stringify(e)}`),a.length}catch(t){return console.error("Error logging training data:",t),((r=(await chrome.storage.local.get("trainingData")).trainingData)==null?void 0:r.length)||0}}function k(e){if(!l)throw new Error("Model not loaded for prediction.");const o=c.map(t=>Number(e[t])||0);if(o.some(t=>!Number.isFinite(t))){console.error("Invalid feature vector contains non-finite values:",o,"Original features:",e);const t=o.map(a=>Number.isFinite(a)?a:0);console.warn("Using cleaned vector:",t),o=t}return S(()=>{try{const t=f([o]),a=l.predict(t);if(a instanceof $){const d=a.dataSync()[0];return a.dispose(),d}else throw console.error("Prediction result was not a Tensor:",a),new Error("Prediction failed internally (result not a Tensor).")}catch(t){throw console.error("Error during prediction inside tf.tidy:",t),t}})}async function v(){console.log("ReelSense: Starting model training...");const o=(await chrome.storage.local.get("trainingData")).trainingData;if(!o||o.length<20)throw new Error(`Not enough training data (${(o==null?void 0:o.length)||0}/20). Keep using the extension!`);const r=o.filter(n=>n&&typeof n.label=="number"&&typeof n.features=="object"&&c.every(i=>typeof n.features[i]=="number"&&Number.isFinite(n.features[i])));if(r.length<20)throw new Error(`Not enough valid training data (${r.length}/20) after filtering.`);b(r);const t=r.map(n=>c.map(i=>n.features[i])),a=r.map(n=>n.label),d=f(t),g=f(a,[a.length,1]),s=x();s.add(w({inputShape:[c.length],units:10,activation:"relu"})),s.add(w({units:1,activation:"sigmoid"})),s.compile({optimizer:E.adam(.001),loss:"binaryCrossentropy",metrics:["accuracy"]}),console.log(`Training on ${r.length} valid samples...`);const u=await s.fit(d,g,{epochs:30,batchSize:16,shuffle:!0,validationSplit:.2,callbacks:{onEpochEnd:(n,i)=>console.log(`Epoch ${n+1}/30: loss=${i.loss.toFixed(3)}, acc=${i.acc.toFixed(3)}, val_loss=${i.val_loss.toFixed(3)}, val_acc=${i.val_acc.toFixed(3)}`)}});console.log("Training history:",u.history),await H(s),l=s,console.log("ReelSense: Model trained and saved successfully."),d.dispose(),g.dispose()}async function H(e){try{const o=await e.save(_(async r=>r));await chrome.storage.local.set({"reelsense-model-artifacts":o}),console.log("Model artifacts saved to chrome.storage.local")}catch(o){console.error("Error saving model:",o)}}async function p(){try{const o=(await chrome.storage.local.get("reelsense-model-artifacts"))["reelsense-model-artifacts"];o&&o.modelTopology&&o.weightData?(l=await F(N(o.modelTopology,o.weightSpecs,o.weightData)),console.log("ReelSense: AI Model loaded from chrome.storage.local."),l&&(S(()=>{l.predict(A([1,c.length]))}),console.log("Model warmed up."))):(console.log("ReelSense: No valid saved model artifacts found in storage."),l=null)}catch(e){console.error("Error loading model from storage:",e),l=null,console.log("Clearing potentially corrupted model data from storage."),await chrome.storage.local.remove("reelsense-model-artifacts")}}async function O(e,o){try{await m();const t=(await chrome.storage.local.get("dailyStats")).dailyStats;t&&t[e]?(o.time&&(t[e].time=(t[e].time||0)+o.time),o.videos&&(t[e].videos=(t[e].videos||0)+o.videos),o.mindlessScore&&(t.totalMindlessScore=(t.totalMindlessScore||0)+o.mindlessScore,t.highestMindlessScore=Math.max(t.highestMindlessScore||0,o.mindlessScore)),await chrome.storage.local.set({dailyStats:t})):console.warn("Could not update stats, platform data missing:",e,t)}catch(r){console.error("Error in updateDailyStats:",r)}}async function U(e,o){try{await m();const t=(await chrome.storage.local.get("dailyStats")).dailyStats;t&&t[e]?(t[e].interventions=(t[e].interventions||0)+1,await chrome.storage.local.set({dailyStats:t}),console.log(`Intervention recorded for ${e}. Total: ${t[e].interventions}`)):console.warn("Could not record intervention, platform data missing:",e,t)}catch(r){console.error("Error in recordIntervention:",r)}}
